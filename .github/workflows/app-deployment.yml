name: Application CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  STAGING_SERVER: 178.254.23.139
  DEPLOY_USER: deploy
  APP_NAME: social-media-downloader

jobs:
  test:
    name: Run Tests and Code Quality Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout application code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov black flake8
        
    - name: Auto-format code with Black
      run: |
        black app.py --line-length 79
        
    - name: Verify Black formatting
      run: |
        black app.py --check --line-length 79
        
    - name: Run linting with Flake8
      run: |
        flake8 app.py --max-line-length=79 --show-source
        
    - name: Run unit tests with coverage
      run: |
        if [ -d "tests" ]; then
          python -m pytest tests/ -v --cov=app --cov-report=xml --cov-report=term
        else
          echo "No tests directory found, creating sample test structure"
          mkdir -p tests
          echo 'def test_example(): assert True' > tests/test_example.py
          python -m pytest tests/ -v
        fi
        
    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  package:
    name: Create Deployment Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python and format code
      run: |
        pip install black
        black app.py --line-length 79
        
    - name: Create stable deployment package
      run: |
        # Cr√©er directement le package dans /tmp
        tar -czf /tmp/deployment-package-${{ github.sha }}.tar.gz \
          --exclude='.git' \
          --exclude='.github' \
          --exclude='.gitignore' \
          --exclude='*.pyc' \
          --exclude='venv' \
          --exclude='tests' \
          --exclude='__pycache__' \
          --exclude='.coverage' \
          --exclude='htmlcov' \
          --exclude='.pytest_cache' \
          --exclude='downloads' \
          .
        
        # Copier le package dans le workspace
        cp /tmp/deployment-package-${{ github.sha }}.tar.gz .
          
    - name: Upload deployment package artifact
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package-${{ github.sha }}
        path: deployment-package-*.tar.gz
        retention-days: 30
        
    - name: Display package info
      run: |
        echo "Deployment package created:"
        ls -lh deployment-package-*.tar.gz

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install security tools
      run: |
        pip install bandit safety
        
    - name: Run Bandit security scan
      run: |
        bandit -r app.py -f html -o bandit-report.html || true
        
    - name: Run Safety dependency check
      run: |
        safety check --json --output safety-report.json || true
        
    - name: Upload security reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports-${{ github.sha }}
        path: |
          bandit-report.html
          safety-report.json
        retention-days: 30

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [package, security-scan]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
    - name: Download deployment package
      uses: actions/download-artifact@v4
      with:
        name: deployment-package-${{ github.sha }}
        
    - name: Setup SSH for Ed25519
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # √âcrire la cl√© Ed25519
        echo "${{ secrets.SSH_PRIVATE_KEY_1BLU }}" > ~/.ssh/staging_key
        chmod 600 ~/.ssh/staging_key
        
        # Valider la cl√©
        echo "‚úÖ Ed25519 SSH key validated:"
        ssh-keygen -l -f ~/.ssh/staging_key
        
        # Scanner et ajouter l'h√¥te
        echo "üåê Adding staging server to known_hosts..."
        ssh-keyscan -H $STAGING_SERVER >> ~/.ssh/known_hosts
        chmod 600 ~/.ssh/known_hosts

    - name: Comprehensive SSH diagnostics
      run: |
        echo "üîç Comprehensive SSH Diagnostics"
        echo "================================="
        
        # 1. V√©rifier la connectivit√© r√©seau
        echo ""
        echo "1. üì° Network connectivity test:"
        echo "Testing connection to $STAGING_SERVER:22"
        if nc -zv -w 5 $STAGING_SERVER 22; then
          echo "‚úÖ Port 22 is open and accessible"
        else
          echo "‚ùå Cannot reach port 22 on $STAGING_SERVER"
          echo "This could be due to:"
          echo "   - Server is down"
          echo "   - Firewall blocking port 22"
          echo "   - Network connectivity issues"
          exit 1
        fi
        
        # 2. V√©rifier la cl√©
        echo ""
        echo "2. üîë SSH key verification:"
        echo "Key fingerprint:"
        ssh-keygen -l -f ~/.ssh/staging_key
        echo "Key type:"
        file ~/.ssh/staging_key
        
        # 3. V√©rifier les permissions
        echo ""
        echo "3. üìÅ File permissions:"
        ls -la ~/.ssh/
        
        # 4. Test avec diff√©rentes options
        echo ""
        echo "4. üîó Testing connection with different methods:"
        
        # M√©thode 1: Simple test
        echo ""
        echo "Method 1: Basic connection test"
        set +e
        ssh -i ~/.ssh/staging_key \
            -o ConnectTimeout=10 \
            -o PasswordAuthentication=no \
            -o BatchMode=yes \
            $DEPLOY_USER@$STAGING_SERVER "echo '‚úÖ Method 1: Basic connection successful'" 
        BASIC_EXIT_CODE=$?
        set -e
        
        if [ $BASIC_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ Method 1: Success"
        else
          echo "‚ùå Method 1: Failed with exit code $BASIC_EXIT_CODE"
        fi
        
        # M√©thode 2: Avec verbose pour diagnostic
        echo ""
        echo "Method 2: Verbose connection test"
        set +e
        ssh -i ~/.ssh/staging_key \
            -o ConnectTimeout=10 \
            -o LogLevel=DEBUG1 \
            -v \
            $DEPLOY_USER@$STAGING_SERVER "echo '‚úÖ Method 2: Verbose connection successful'"
        VERBOSE_EXIT_CODE=$?
        set -e
        
        if [ $VERBOSE_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ Method 2: Success"
        else
          echo "‚ùå Method 2: Failed with exit code $VERBOSE_EXIT_CODE"
          echo ""
          echo "üîß Common issues and solutions:"
          echo "   - Ensure public key is in /home/$DEPLOY_USER/.ssh/authorized_keys on server"
          echo "   - Check file permissions on server: chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
          echo "   - Verify SSH service is running on server: sudo systemctl status ssh"
          echo "   - Check if user '$DEPLOY_USER' exists on server"
          exit 1
        fi

    - name: Transfer deployment package
      run: |
        echo "üì¶ Transferring deployment package to staging server..."
        scp -i ~/.ssh/staging_key \
            -o ConnectTimeout=10 \
            deployment-package-*.tar.gz \
            $DEPLOY_USER@$STAGING_SERVER:/tmp/
        echo "‚úÖ Package transferred successfully"
        
    - name: Execute deployment on staging
      run: |
        echo "üöÄ Starting deployment on staging server..."
        ssh -i ~/.ssh/staging_key \
            -o ConnectTimeout=10 \
            $DEPLOY_USER@$STAGING_SERVER "
            set -e
            echo 'üìã Deployment script started...'
            
            # Create backup of current deployment
            BACKUP_DIR=\"/home/$DEPLOY_USER/backups/backup_\$(date +%Y%m%d_%H%M%S)\"
            echo 'üì¶ Creating backup in: '\$BACKUP_DIR
            mkdir -p \$BACKUP_DIR
            
            if [ -d \"/home/$DEPLOY_USER/$APP_NAME\" ]; then
              echo 'üíæ Backing up current version...'
              cp -r /home/$DEPLOY_USER/$APP_NAME/* \$BACKUP_DIR/ 2>/dev/null || true
            fi
            
            # Extract new deployment
            echo 'üìÇ Extracting new deployment package...'
            mkdir -p /home/$DEPLOY_USER/$APP_NAME
            tar -xzf /tmp/deployment-package-${{ github.sha }}.tar.gz -C /home/$DEPLOY_USER/$APP_NAME
            
            # Set up Python virtual environment
            echo 'üêç Setting up Python environment...'
            cd /home/$DEPLOY_USER/$APP_NAME
            python3 -m venv venv
            source venv/bin/activate
            pip install --upgrade pip
            pip install -r requirements.txt
            
            # Clean up
            rm -f /tmp/deployment-package-${{ github.sha }}.tar.gz
            
            echo '‚úÖ Deployment completed successfully!'
            echo 'üìÅ Application location: /home/$DEPLOY_USER/$APP_NAME'
            echo 'üîß Virtual environment: /home/$DEPLOY_USER/$APP_NAME/venv'
        "
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        ssh -i ~/.ssh/staging_key \
            -o ConnectTimeout=10 \
            $DEPLOY_USER@$STAGING_SERVER "
            set -e
            echo 'üîç Running deployment verification...'
            cd /home/$DEPLOY_USER/$APP_NAME
            
            # Check if main application file exists
            if [ -f 'app.py' ]; then
              echo '‚úÖ Main application file found'
            else
              echo '‚ùå Main application file missing'
              exit 1
            fi
            
            # Check virtual environment
            if [ -d 'venv' ]; then
              echo '‚úÖ Virtual environment exists'
            else
              echo '‚ùå Virtual environment missing'
              exit 1
            fi
            
            # Test Python import
            source venv/bin/activate
            if python -c 'import sys; print(\"‚úÖ Python path:\", sys.path)'; then
              echo '‚úÖ Python environment working'
            else
              echo '‚ùå Python environment issue'
              exit 1
            fi
            
            # Test requirements installation
            if pip list | grep -q 'requests'; then
              echo '‚úÖ Dependencies installed'
            else
              echo '‚ùå Dependencies not properly installed'
            fi
            
            echo 'üéâ Deployment verification successful!'
        "
        
    - name: Cleanup SSH key
      run: |
        rm -f ~/.ssh/staging_key
        echo "‚úÖ SSH key cleaned up"

  notify:
    name: Notify Pipeline Status
    runs-on: ubuntu-latest
    needs: [test, package, security-scan, deploy-staging]
    if: always()
    
    steps:
    - name: Notify pipeline completion
      run: |
        echo "=== CI/CD Pipeline Completion ==="
        echo "üìã Workflow: ${{ github.workflow }}"
        echo "üîó SHA: ${{ github.sha }}"
        echo "üéØ Branch: ${{ github.ref }}"
        echo "üìä Job Status:"
        echo "   - Test: ${{ needs.test.result }}"
        echo "   - Security Scan: ${{ needs.security-scan.result }}"
        echo "   - Package: ${{ needs.package.result }}"
        echo "   - Staging Deployment: ${{ needs.deploy-staging.result }}"
        echo ""
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ All CI/CD checks passed successfully!"
          echo "üåê Staging Server: $STAGING_SERVER"
          echo "üë§ Deploy User: $DEPLOY_USER"
          echo "üì¶ Application: $APP_NAME"
          echo "üöÄ Application successfully deployed to staging!"
        else
          echo "‚ùå Some CI/CD checks failed"
          echo "Please check the failed jobs and fix the issues"
        fi

  cleanup:
    name: Cleanup Workflow
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Cleanup workflow run
      run: |
        echo "üßπ Cleaning up workflow temporary resources"
        echo "Workflow completed with overall status: ${{ job.status }}"