# ==============================================================================
# Workflow: Continuous Integration and Continuous Deployment (CI/CD)
# Description: This workflow builds, tests, and deploys the application
#              to a self-managed Virtual Private Server (VPS) via SSH.
# ==============================================================================
name: CI/CD Pipeline to VPS

# ------------------------------------------------------------------------------
# Workflow Triggers
# ------------------------------------------------------------------------------
on:
  # Run on push events to the main branch
  push:
    branches:
      - main
  # Run on pull request events targeting the main branch
  pull_request:
    branches:
      - main
  # Allow manual execution of the workflow
  workflow_dispatch:

# ------------------------------------------------------------------------------
# Environment Variables
# Define common variables to be used across jobs
# ------------------------------------------------------------------------------
env:
  PYTHON_VERSION: '3.10' # Use a recent, widely supported Python version
  VPS_HOST: 178.254.23.139
  VPS_APP_PATH: /opt/project-name # Use a generic, professional project path

# ------------------------------------------------------------------------------
# Jobs
# ------------------------------------------------------------------------------
jobs:
  ## Job 1: Build and Test
  build-and-test:
    name: Build & Test Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4 # Use the latest version
        
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5 # Use the latest version
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          
      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          
      - name: Execute Unit and Integration Tests
        run: |
          # Replace this placeholder with your actual test command (e.g., pytest)
          echo "Running tests..."
          # pytest ./tests/
          echo "Tests finished successfully."


  ## Job 2: Deploy to VPS
  deploy:
    name: Deploy to Production VPS
    # Only run the deployment if the tests pass
    needs: build-and-test
    runs-on: ubuntu-latest
    # Only deploy on pushes to the main branch, not pull requests
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Note: Building and pushing a Docker image is usually done to a registry (e.g., Docker Hub)
      # In this direct VPS deployment, we rely on the VPS to build the image locally.
      # If you were pushing, this step would be for login and push.
      - name: Log in to Docker Registry (Optional: If pushing an image)
        # Add docker login command here if you are using a registry
        run: echo "Skipping registry login, building on VPS instead."

      - name: Deploy via SSH and Docker Compose
        uses: appleboy/ssh-action@v1.0.3 # Use a more recent version
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            echo "--- Starting Deployment on VPS ---"
            # 1. Navigate to the application directory
            cd ${{ env.VPS_APP_PATH }}
            
            # 2. Pull the latest code from GitHub
            echo "Pulling latest code..."
            git pull origin main
            
            # 3. Gracefully stop existing services
            echo "Stopping and removing existing containers..."
            docker-compose down -v
            
            # 4. Rebuild images and restart services (using --no-cache is good practice for fresh build)
            echo "Building new images and starting services in detached mode..."
            docker-compose build --no-cache
            docker-compose up -d
            
            # 5. Clean up unused Docker images
            echo "Pruning unused Docker images..."
            docker image prune -f
            
            # 6. Wait for service stability
            echo "Waiting 30 seconds for services to initialize..."
            sleep 30
            
            # 7. Final Health Check
            echo "Running final application health check..."
            # Replace 8501 with the actual port of your service if different
            curl -f http://localhost:8501/healthz
            
            # Check the exit status of curl
            if [ $? -eq 0 ]; then
                echo "✅ Deployment completed successfully and health check passed!"
            else
                echo "❌ Deployment failed! Health check failed."
                exit 1
            fi